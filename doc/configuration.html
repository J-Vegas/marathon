<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Marathon</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Cross-platform test runner written for Android and iOS projects">
    <meta name="keywords" content="android, testing, testing-tool, test-runner, espresso, uitest, uitesting, uitests, ios, marathon, xcrun, instrumentation, instrumentation-tests, gradle, parallel, performance">

    <!-- Font Awesome -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css" rel="stylesheet"
          type="text/css">
    <!-- Animated -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="shortcut icon" href="/marathon/img/favicon.png">
    <!-- highlight  css -->
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.1/styles/solarized-dark.min.css">
    <!-- main css -->
    <link rel="stylesheet" type="text/css" href="/marathon/css/marathon.css">
    <!-- tabs -->
    <link rel="stylesheet" type="text/css" href="/marathon/css/tabs.css">

    <!-- Diagrams support -->
    <script src="/marathon/js/dagre.min.js"></script>
    <script src="/marathon/js/lodash.min.js"></script>
    <script src="/marathon/js/nomnoml.js"></script>
    <script src="/marathon/js/diagrams.js"></script>

    
    <script>
    (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
            (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
            m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-131132823-2', 'auto');
    ga('send', 'pageview');


</script>

    
</head>

<body id="doc-body">
<div id="wrapper">
    <div id="sidebar-wrapper">
    <div>
      <a class="brand" href="/marathon/">
            <img src="/marathon/img/marathon-brand-sidebar.svg" alt="">
      </a>
      <a href="javascript:void(0)" id="main-toggle" class="sidebar-toggle">
            <i class="fa fa-bars"></i>
      </a>
    </div>
    <ul class="sidebar-nav">
    
        
        
        <li class="sidebar-nav-item">
          <a href="#">
            <span>General</span>
            <i class="fa fa-angle-down"></i>
          </a>
          <ul>
            
            
            <li data-order="1">
              <a href="/marathon/doc/getting-started.html">
                  <i class="fa fa-circle"></i>
                  <span>Getting Started</span>
              </a>
            </li>
            
            <li data-order="2">
              <a href="/marathon/doc/downloading.html">
                  <i class="fa fa-circle"></i>
                  <span>Downloading</span>
              </a>
            </li>
            
            <li data-order="3">
              <a href="/marathon/doc/configuration.html">
                  <i class="fa fa-circle"></i>
                  <span>Options</span>
              </a>
            </li>
            
            <li data-order="5">
              <a href="/marathon/doc/executing.html">
                  <i class="fa fa-circle"></i>
                  <span>Executing</span>
              </a>
            </li>
            
            <li data-order="6">
              <a href="/marathon/doc/reports.html">
                  <i class="fa fa-circle"></i>
                  <span>Reporting</span>
              </a>
            </li>
            
            <li data-order="7">
              <a href="/marathon/doc/faq.html">
                  <i class="fa fa-circle"></i>
                  <span>FAQ</span>
              </a>
            </li>
            
            <li data-order="8">
              <a href="/marathon/doc/special-thanks.html">
                  <i class="fa fa-circle"></i>
                  <span>Special thanks</span>
              </a>
            </li>
            
          </ul>
        </li>
    
        
        
        <li class="sidebar-nav-item">
          <a href="#">
            <span>Reference</span>
            <i class="fa fa-angle-down"></i>
          </a>
          <ul>
            
            
            <li data-order="">
              <a href="/marathon/ref/samples.html">
                  <i class="fa fa-circle"></i>
                  <span>Samples</span>
              </a>
            </li>
            
          </ul>
        </li>
    
        
        
        <li class="sidebar-nav-item">
          <a href="#">
            <span>Vendor extensions</span>
            <i class="fa fa-angle-down"></i>
          </a>
          <ul>
            
            
            <li data-order="1">
              <a href="/marathon/ven/android.html">
                  <i class="fa fa-circle"></i>
                  <span>Android</span>
              </a>
            </li>
            
            <li data-order="2">
              <a href="/marathon/ven/ios.html">
                  <i class="fa fa-circle"></i>
                  <span>iOS</span>
              </a>
            </li>
            
          </ul>
        </li>
    
        
        
        <li class="sidebar-nav-item">
          <a href="#">
            <span>Developers</span>
            <i class="fa fa-angle-down"></i>
          </a>
          <ul>
            
            
            <li data-order="2">
              <a href="/marathon/dev/contributing.html">
                  <i class="fa fa-circle"></i>
                  <span>Contributing</span>
              </a>
            </li>
            
            <li data-order="3">
              <a href="/marathon/dev/vision.html">
                  <i class="fa fa-circle"></i>
                  <span>Vision</span>
              </a>
            </li>
            
          </ul>
        </li>
    
    </ul>

</div>

    <div id="doc-wrapper">
    <div class="doc-header">
        <a href="javascript:void(0)" id="main-toggle" class="sidebar-toggle">
            <i class="fa fa-bars"></i>
        </a>
        <div class="search-wrapper">
            <input class="search" id="docsearch" placeholder="Search documentation..." type="search">
        </div>
    </div>
    <div class="doc-content">
        
        <p>Configuration for CLI is done using the YAML formatted configuration file which is placed by default in the root of the project and named as
 <strong>Marathonfile</strong>.</p>

<p>Below is an example of Marathonfile (without the vendor module configuration:</p>

<pre><code class="language-yaml">name: "sample-app tests"
outputDir: "./marathon"
analyticsConfiguration:
  influx:
    url: "http://influx.svc.cluster.local:8086"
    user: "root"
    password: "root"
    dbName: "marathon"
poolingStrategy:
- type: "omni"
shardingStrategy:
  type: "count"
  count: 5
sortingStrategy:
  type: "success-rate"
  timeLimit: "2015-03-14T09:26:53.590Z"
batchingStrategy:
  type: "fixed-size"
  size: 5
flakinessStrategy:
  type: "probability"
  minSuccessRate: 0.7
  maxCount: 3
  timeLimit: "2015-03-14T09:26:53.590Z"
retryStrategy:
  type: "fixed-quota"
  totalAllowedRetryQuota: 100
  retryPerTestQuota: 3
</code></pre>

<p>Each of these options is covered in detail in the section below. If you’re unsure how to properly format your options in Marathonfile take
 a look at the samples or take a look at the <a href="https://github.com/Malinskiy/marathon/blob/develop/cli/src/main/kotlin/com/malinskiy/marathon/cli/config/ConfigFactory.kt">deserialisation logic</a> in the <em>cli</em> module of the project. Each option might have a default
 deserialiser from yaml or a custom one. Usually the custom deserialiser expects the type option to understand which type of strategy we
 need to instantiate.</p>

<p>Configuration for gradle plugin is done via gradle only. It doesn’t support the CLI’s marathonfile.
Here is an example of gradle config using Kotlin DSL:</p>

<pre><code class="language-kotlin">marathon {
    name = "sample-app tests"
    baseOutputDir = "./marathon"
    analytics {
        influx {
            url = "http://influx.svc.cluster.local:8086"
            user = "root"
            password = "root"
            dbName = "marathon"
        }
    }
    poolingStrategy {
        operatingSystem = true
    }
    shardingStrategy {
        countSharding {
            count = 5
        }
    }
    sortingStrategy {
        executionTime {
            percentile = 90.0
            executionTime = Instant.now().minus(3, ChronoUnit.DAYS)
        }
    }
    batchingStrategy {
        fixedSize {
            size = 10
        }
    }
    flakinessStrategy {
        probabilityBased {
            minSuccessRate = 0.8
            maxCount = 3
            timeLimit = Instant.now().minus(30, ChronoUnit.DAYS)
        }
    }
    retryStrategy {
        fixedQuota {
            totalAllowedRetryQuota = 200
            retryPerTestQuota = 3
        }
    }
    filteringConfiguration {
        allowlist {
            add(SimpleClassnameFilter(".*".toRegex()))
        }
        blocklist {
            add(SimpleClassnameFilter("$^".toRegex()))
        }
    }
    testClassRegexes = listOf("^((?!Abstract).)*Test$")
    includeSerialRegexes = emptyList()
    excludeSerialRegexes = emptyList()
    uncompletedTestRetryQuota = 100
    ignoreFailures = false
    isCodeCoverageEnabled = false
    fallbackToScreenshots = false
    testOutputTimeoutMillis = 30_000
    strictMode = false
    debug = true
    autoGrantPermission = true
}
</code></pre>

<p>Here you will find a list of currently supported configuration parameters and examples of how to set them up. Keep in mind that some of the
 additional parameters might not be supported by all vendor modules. If you find that something doesn’t work - please submit an issue for a
 vendor module at fault.</p>

<ul id="markdown-toc">
  <li><a href="#general-parameters" id="markdown-toc-general-parameters">General parameters</a>    <ul>
      <li><a href="#test-run-configuration-name" id="markdown-toc-test-run-configuration-name">Test run configuration name</a></li>
      <li><a href="#output-directory" id="markdown-toc-output-directory">Output directory</a></li>
    </ul>
  </li>
  <li><a href="#analytics-configuration" id="markdown-toc-analytics-configuration">Analytics configuration</a>    <ul>
      <li><a href="#disabled-analytics" id="markdown-toc-disabled-analytics">Disabled analytics</a></li>
      <li><a href="#influxdb" id="markdown-toc-influxdb">InfluxDB</a></li>
      <li><a href="#graphite" id="markdown-toc-graphite">Graphite</a></li>
    </ul>
  </li>
  <li><a href="#execution-flow" id="markdown-toc-execution-flow">Execution flow</a>    <ul>
      <li><a href="#pooling-strategy" id="markdown-toc-pooling-strategy">Pooling strategy</a>        <ul>
          <li><a href="#omni-aka-one-huge-pool" id="markdown-toc-omni-aka-one-huge-pool">Omni a.k.a. one huge pool</a></li>
          <li><a href="#by-abi" id="markdown-toc-by-abi">By abi</a></li>
          <li><a href="#by-manufacturer" id="markdown-toc-by-manufacturer">By manufacturer</a></li>
          <li><a href="#by-device-model" id="markdown-toc-by-device-model">By device model</a></li>
          <li><a href="#by-os-version" id="markdown-toc-by-os-version">By OS version</a></li>
        </ul>
      </li>
      <li><a href="#sharding-strategy" id="markdown-toc-sharding-strategy">Sharding strategy</a>        <ul>
          <li><a href="#parallel-sharding" id="markdown-toc-parallel-sharding">Parallel sharding</a></li>
          <li><a href="#count-sharding" id="markdown-toc-count-sharding">Count sharding</a></li>
        </ul>
      </li>
      <li><a href="#sorting-strategy" id="markdown-toc-sorting-strategy">Sorting strategy</a>        <ul>
          <li><a href="#no-sorting" id="markdown-toc-no-sorting">No sorting</a></li>
          <li><a href="#success-rate-sorting" id="markdown-toc-success-rate-sorting">Success rate sorting</a></li>
          <li><a href="#execution-time-sorting" id="markdown-toc-execution-time-sorting">Execution time sorting</a></li>
        </ul>
      </li>
      <li><a href="#batching-strategy" id="markdown-toc-batching-strategy">Batching strategy</a>        <ul>
          <li><a href="#isolate-batching" id="markdown-toc-isolate-batching">Isolate batching</a></li>
          <li><a href="#fixed-size-batching" id="markdown-toc-fixed-size-batching">Fixed size batching</a></li>
        </ul>
      </li>
      <li><a href="#flakiness-strategy" id="markdown-toc-flakiness-strategy">Flakiness strategy</a>        <ul>
          <li><a href="#ignore-flakiness" id="markdown-toc-ignore-flakiness">Ignore flakiness</a></li>
          <li><a href="#probability-based-flakiness-strategy" id="markdown-toc-probability-based-flakiness-strategy">Probability based flakiness strategy</a></li>
        </ul>
      </li>
      <li><a href="#retry-strategy" id="markdown-toc-retry-strategy">Retry strategy</a>        <ul>
          <li><a href="#no-retries" id="markdown-toc-no-retries">No retries</a></li>
          <li><a href="#fixed-quota-retry-strategy" id="markdown-toc-fixed-quota-retry-strategy">Fixed quota retry strategy</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#additional-parameters" id="markdown-toc-additional-parameters">Additional parameters</a>    <ul>
      <li><a href="#test-filtering-configuration" id="markdown-toc-test-filtering-configuration">Test filtering configuration</a></li>
      <li><a href="#test-class-regular-expression" id="markdown-toc-test-class-regular-expression">Test class regular expression</a></li>
      <li><a href="#ignore-failures" id="markdown-toc-ignore-failures">Ignore failures</a></li>
      <li><a href="#test-output-timeout" id="markdown-toc-test-output-timeout">Test output timeout</a></li>
      <li><a href="#test-batch-timeout" id="markdown-toc-test-batch-timeout">Test batch timeout</a></li>
      <li><a href="#device-provider-init-timeout" id="markdown-toc-device-provider-init-timeout">Device provider init timeout</a></li>
      <li><a href="#analytics-tracking" id="markdown-toc-analytics-tracking">Analytics tracking</a></li>
      <li><a href="#uncompleted-test-retry-quota" id="markdown-toc-uncompleted-test-retry-quota">Uncompleted test retry quota</a></li>
      <li><a href="#strict-mode" id="markdown-toc-strict-mode">Strict mode</a></li>
      <li><a href="#debug-mode" id="markdown-toc-debug-mode">Debug mode</a></li>
      <li><a href="#screen-recording-policy" id="markdown-toc-screen-recording-policy">Screen recording policy</a></li>
    </ul>
  </li>
  <li><a href="#vendor-configuration" id="markdown-toc-vendor-configuration">Vendor configuration</a></li>
</ul>

<h1 id="general-parameters">General parameters</h1>

<h2 id="test-run-configuration-name">Test run configuration name</h2>
<p>This string specifies the name of this test run configuration. It is used mainly in the generated test reports.</p>

<ul class="tab" data-tab="90dfe9b3-acd0-45a0-b781-870b26dc0464">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="90dfe9b3-acd0-45a0-b781-870b26dc0464">
    
        <li class="active">
<pre><code class="language-yaml">name: "My test run for sample app"
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    name = "My test run for sample app"
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    name = "My test run for sample app"
}
</code></pre>
</li>
    
</ul>

<h2 id="output-directory">Output directory</h2>
<p>Directory path to use as the root folder for all the runner output (logs, reports, etc).</p>

<p>For gradle, the output path will automatically be set to a <code>marathon</code> folder in your reports folder unless it’s overridden.</p>

<ul class="tab" data-tab="f3e55e68-c232-404f-a215-eabbc8ac2dab">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="f3e55e68-c232-404f-a215-eabbc8ac2dab">
    
        <li class="active">
<pre><code class="language-yaml">outputDir: "build/reports/marathon"
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    baseOutputDir = "some-path"
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    baseOutputDir = "some-path"
}
</code></pre>
</li>
    
</ul>

<h1 id="analytics-configuration">Analytics configuration</h1>
<p>Configuration of analytics backend to be used for storing and retrieving test metrics. This plays a major part in optimising performance and mitigating flakiness.</p>

<h2 id="disabled-analytics">Disabled analytics</h2>
<p>By default no analytics backend is expected which means that each test will be treated as a completely new test.</p>

<h2 id="influxdb"><a href="https://www.influxdata.com/">InfluxDB</a></h2>
<p>Assuming you’ve done the setup for InfluxDB you need to provide:</p>
<ul>
  <li>url</li>
  <li>username</li>
  <li>password</li>
  <li>database name</li>
  <li>retention policy</li>
</ul>

<p>Database name is quite useful in case you have multiple configurations of tests/devices and you don’t want metrics from one configuration to affect the other one, e.g. regular and end-to-end tests.</p>

<ul class="tab" data-tab="ee62030b-af7a-42e8-b545-fe3ba429254f">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="ee62030b-af7a-42e8-b545-fe3ba429254f">
    
        <li class="active">
<pre><code class="language-yaml">analyticsConfiguration:
  influx:
    url: "http://influx.svc.cluster.local:8086"
    user: "root"
    password: "root"
    dbName: "marathon"
    retentionPolicyConfiguration:
      name: "rpMarathonTest"
      duration: "90d"
      shardDuration: "1h"
      replicationFactor: 5
      isDefault: false
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    analytics {
        influx {
            url = "http://influx.svc.cluster.local:8086"
            user = "root"
            password = "root"
            dbName = "marathon"
        }
    }
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    analytics {
        influx {
            url = "http://influx.svc.cluster.local:8086"
            user = "root"
            password = "root"
            dbName = "marathon"
        }
    }
}
</code></pre>
</li>
    
</ul>

<h2 id="graphite"><a href="https://graphiteapp.org/">Graphite</a></h2>
<p>Graphite can be used as an alternative to InfluxDB. It uses the following parameters:</p>
<ul>
  <li>host</li>
  <li>port (optional) - the default is 2003</li>
  <li>prefix (optional) - no metrics prefix will be used if not specified</li>
</ul>

<ul class="tab" data-tab="894378f4-759f-4efe-88a2-0651c15ca1ce">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="894378f4-759f-4efe-88a2-0651c15ca1ce">
    
        <li class="active">
<pre><code class="language-yaml">analyticsConfiguration:
  graphite:
    host: "influx.svc.cluster.local"
    port: "8080"
    prefix: "prf"
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    analytics {
        graphite {
            host = "influx.svc.cluster.local"
            port = "8080"
            prefix = "prf"
        }
    }
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    analytics {
        graphite {
            host = "influx.svc.cluster.local"
            port = "8080"
            prefix = "prf"
        }
    }
}
</code></pre>
</li>
    
</ul>

<h1 id="execution-flow">Execution flow</h1>

<h2 id="pooling-strategy">Pooling strategy</h2>
<p>Pooling strategy affects how devices are grouped together.</p>

<h3 id="omni-aka-one-huge-pool">Omni a.k.a. one huge pool</h3>
<p>All connected devices are merged into one group. <strong>This is the default mode</strong>.</p>

<ul class="tab" data-tab="09c466ab-94c7-4b2a-a45f-8874fbb9bb88">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="09c466ab-94c7-4b2a-a45f-8874fbb9bb88">
    
        <li class="active">
<pre><code class="language-yaml">poolingStrategy:
  - type: "omni"
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    //Omni is the default strategy
    poolingStrategy {}
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    //Omni is the default strategy
    poolingStrategy {}
}
</code></pre>
</li>
    
</ul>

<h3 id="by-abi">By abi</h3>
<p>Devices are grouped by their ABI, e.g. <em>x86</em> and <em>mips</em>.</p>

<ul class="tab" data-tab="9f169f3b-3e85-422b-9680-288dc5bcfde6">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="9f169f3b-3e85-422b-9680-288dc5bcfde6">
    
        <li class="active">
<pre><code class="language-yaml">poolingStrategy:
  - type: "abi"
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    poolingStrategy {
        abi = true
    }
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    poolingStrategy {
        abi = true
    }
}
</code></pre>
</li>
    
</ul>

<h3 id="by-manufacturer">By manufacturer</h3>
<p>Devices are grouped by manufacturer, e.g. <em>Samsung</em> and <em>Yota</em>.</p>

<ul class="tab" data-tab="5494e507-429d-408a-88fc-169eede318ad">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="5494e507-429d-408a-88fc-169eede318ad">
    
        <li class="active">
<pre><code class="language-yaml">poolingStrategy:
  - type: "manufacturer"
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    poolingStrategy {
        manufacturer = true
    }
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    poolingStrategy {
        manufacturer = true
    }
}
</code></pre>
</li>
    
</ul>

<h3 id="by-device-model">By device model</h3>
<p>Devices are grouped by model name, e.g. <em>LG-D855</em> and <em>SM-N950F</em>.</p>

<ul class="tab" data-tab="6597ac6c-a36e-41c5-b729-735c2096aac4">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="6597ac6c-a36e-41c5-b729-735c2096aac4">
    
        <li class="active">
<pre><code class="language-yaml">poolingStrategy:
  - type: "device-model"
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    poolingStrategy {
        model = true
    }
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    poolingStrategy {
        model = true
    }
}
</code></pre>
</li>
    
</ul>

<h3 id="by-os-version">By OS version</h3>
<p>Devices are grouped by OS version, e.g. <em>24</em> and <em>25</em>.</p>

<ul class="tab" data-tab="5551a4cf-4aa1-4296-b43d-cc287fcfd029">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="5551a4cf-4aa1-4296-b43d-cc287fcfd029">
    
        <li class="active">
<pre><code class="language-yaml">poolingStrategy:
  - type: "os-version"
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    poolingStrategy {
        operatingSystem = true
    }
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    poolingStrategy {
        operatingSystem = true
    }
}
</code></pre>
</li>
    
</ul>

<h2 id="sharding-strategy">Sharding strategy</h2>
<p>Sharding is a mechanism that allows the marathon to affect the tests scheduled for execution inside each pool.</p>

<h3 id="parallel-sharding">Parallel sharding</h3>
<p>Executes each test in parallel on all the available devices in pool. This is the default behaviour.</p>

<ul class="tab" data-tab="3fd5dfcb-90db-4f17-a10c-8374be861cb4">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="3fd5dfcb-90db-4f17-a10c-8374be861cb4">
    
        <li class="active">
<pre><code class="language-yaml">shardingStrategy:
  type: "parallel"
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    //Parallel is the default strategy
    shardingStrategy {}
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    //Parallel is the default strategy
    shardingStrategy {}
}
</code></pre>
</li>
    
</ul>

<h3 id="count-sharding">Count sharding</h3>
<p>Executes each test <strong>count</strong> times inside each pool. For example you want to test the flakiness of a specific test hence you need to execute
 this test a lot of times. Instead of running the build X times just use this sharding strategy and the test will be executed X times.</p>

<ul class="tab" data-tab="7f2700e8-a035-4c11-a588-75b199c6c1e6">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="7f2700e8-a035-4c11-a588-75b199c6c1e6">
    
        <li class="active">
<pre><code class="language-yaml">shardingStrategy:
  type: "count"
  count: 5
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    shardingStrategy {
        countSharding { 
            count = 5
        }
    }
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    shardingStrategy {
        countSharding { 
            count = 5
        }
    }
}
</code></pre>
</li>
    
</ul>

<h2 id="sorting-strategy">Sorting strategy</h2>
<p>In order to optimise the performance of test execution tests need to be sorted. 
This requires analytics backend enabled since we need historical data in order to anticipate tests behaviour like duration and 
success/failure rate.</p>

<h3 id="no-sorting">No sorting</h3>
<p>No sorting of tests is done at all. This is the default behaviour.</p>

<ul class="tab" data-tab="31e9e414-426e-4f6f-a468-cebbaa4f66a2">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="31e9e414-426e-4f6f-a468-cebbaa4f66a2">
    
        <li class="active">
<pre><code class="language-yaml">sortingStrategy:
  type: "no-sorting"
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    sortingStrategy {}
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    sortingStrategy {}
}
</code></pre>
</li>
    
</ul>

<h3 id="success-rate-sorting">Success rate sorting</h3>
<p>For each test analytics storage is providing the success rate for a time window specified by time <strong>timeLimit</strong> parameter. 
All the tests are then sorted by the success rate in an increasing order, that is failing tests go first and successful tests go last.
If you want to reverse the order set the <code>ascending</code> to <code>true</code>.</p>

<ul class="tab" data-tab="63e0233d-d577-4a66-99fc-14f9d231c94f">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="63e0233d-d577-4a66-99fc-14f9d231c94f">
    
        <li class="active">
<pre><code class="language-yaml">sortingStrategy:
  type: "success-rate"
  timeLimit: "2015-03-14T09:26:53.590Z"
  ascending: false
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    sortingStrategy {
        successRate { 
            limit = Instant.now().minus(Duration.parse("PT1H"))
            ascending = false
        }
    }
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    sortingStrategy {
        successRate { 
            limit = Instant.now().minus(Duration.parse("PT1H"))
            ascending = false
        }
    }
}
</code></pre>
</li>
    
</ul>

<h3 id="execution-time-sorting">Execution time sorting</h3>
<p>For each test analytics storage is providing the X percentile duration for a time window specified by time <strong>timeLimit</strong> parameter. 
Apart from absolute date/time it  can be also be an ISO 8601 formatted duration.</p>

<p>Percentile is configurable via the <strong>percentile</strong> parameter.</p>

<p>All the tests are sorted so that long tests go first and short tests are executed last. 
This allows marathon to minimise the error of balancing the execution of tests at the end of execution.</p>

<ul class="tab" data-tab="c6c6ef46-89f6-4a87-b43d-a9b5693445ac">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="c6c6ef46-89f6-4a87-b43d-a9b5693445ac">
    
        <li class="active">
<pre><code class="language-yaml">sortingStrategy:
  type: "execution-time"
  percentile: 80.0
  timeLimit: "-PT1H"
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    sortingStrategy {
        executionTime { 
            percentile = 80.0
            timeLimit = Instant.now().minus(Duration.parse("PT1H"))
        }
    }
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    sortingStrategy {
        executionTime { 
            percentile = 80.0
            timeLimit = Instant.now().minus(Duration.parse("PT1H"))
        }
    }
}
</code></pre>
</li>
    
</ul>

<h2 id="batching-strategy">Batching strategy</h2>
<p>Batching mechanism allows you to trade off stability for performance. 
A group of tests executed using one single run is called a batch. 
Most of the times this means that between tests in the same batch you’re sharing the device state so there is no clean-up. 
On the other hand you gain some performance improvements 
since the execution command usually is quite slow (up to 10 seconds for some platforms).</p>

<h3 id="isolate-batching">Isolate batching</h3>
<p>No batching is done at all, each test is executed using separate command execution, that is performance is sacrificed in favor of stability. 
This is the default mode.</p>

<ul class="tab" data-tab="174ed3b5-c397-461b-b007-a42a2a1d6273">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="174ed3b5-c397-461b-b007-a42a2a1d6273">
    
        <li class="active">
<pre><code class="language-yaml">batchingStrategy:
  type: "isolate"
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    batchingStrategy {}
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    batchingStrategy {}
}
</code></pre>
</li>
    
</ul>

<h3 id="fixed-size-batching">Fixed size batching</h3>
<p>Each batch is created based on the <strong>size</strong> parameter which is required. 
When a new batch of tests is needed the queue is dequeued for at most <strong>size</strong> tests.</p>

<p>Optionally if you want to limit the batch duration you have to specify the <strong>timeLimit</strong> for the test metrics time window
and the <strong>durationMillis</strong>.  For each test the analytics backend is accessed and <strong>percentile</strong> of it’s duration is queried. 
If the sum of durations is more than the <strong>durationMillis</strong> then no more tests are added to the batch.</p>

<p>This is useful if you have very very long tests and you use batching, e.g. you batch by size 10 and your test run duration is roughly
 10 minutes, but you have tests that are expected to run 2 minutes each. If you batch all of them together then at least one device will be
 finishing it’s execution in 20 minutes while all other devices might already finish. 
 To mitigate this just specify the time limit for the batch using <strong>durationMillis</strong>.</p>

<p>Another optional parameter for this strategy is the <strong>lastMileLength</strong>. At the end of execution batching tests actually hurts the
 performance so for the last tests it’s much better to execute them in parallel in separate batches. This works only if you execute on 
 multiple devices. You can specify when this optimisation kicks in using the <strong>lastMileLength</strong> parameter, the last <strong>lastMileLength</strong> tests
 will use this optimisation.</p>

<ul class="tab" data-tab="d197b68b-2722-4c93-b686-a91ae11fe725">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="d197b68b-2722-4c93-b686-a91ae11fe725">
    
        <li class="active">
<pre><code class="language-yaml">batchingStrategy:
  type: "fixed-size"
  size: 5
  durationMillis: 100000
  percentile: 80.0
  timeLimit: "-PT1H"
  lastMileLength: 10
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    batchingStrategy {
        fixedSize { 
            size = 5
            durationMillis = 100000
            percentile = 80.0
            timeLimit = Instant.now().minus(Duration.parse("PT1H"))
            lastMileLength = 10
        }
    }
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    batchingStrategy {
        fixedSize { 
            size = 5
            durationMillis = 100000
            percentile = 80.0
            timeLimit = Instant.now().minus(Duration.parse("PT1H"))
            lastMileLength = 10
        }
    }
}
</code></pre>
</li>
    
</ul>

<h2 id="flakiness-strategy">Flakiness strategy</h2>
<p>This is the main anticipation logic for marathon. Using the analytics backend we can understand the success rate and hence queue preventive
 retries to mitigate the flakiness of the tests and environment.</p>

<h3 id="ignore-flakiness">Ignore flakiness</h3>
<p>Nothing is done with this mode. This is the default behaviour.</p>

<ul class="tab" data-tab="427a4115-f841-4a9d-b733-38e6bf7583f8">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="427a4115-f841-4a9d-b733-38e6bf7583f8">
    
        <li class="active">
<pre><code class="language-yaml">flakinessStrategy:
  type: "ignore"
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    flakinessStrategy {}
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    flakinessStrategy {}
}
</code></pre>
</li>
    
</ul>

<h3 id="probability-based-flakiness-strategy">Probability based flakiness strategy</h3>
<p>The main idea is that flakiness strategy anticipates the flakiness of the test based on the probability of test passing and tries to
 maximise the probability of passing when executed multiple times. For example the probability of test A passing is 0.5 and configuration
 has probability of 0.8 requested, then the flakiness strategy multiplies the test A to be executed 3 times (0.5 x 0.5 x 0.5 = 0.125 is
 the probability of all tests failing, so with probability 0.875 &gt; 0.8 at least one of tests will pass).</p>

<p>The minimal probability that you want is specified using <strong>minSuccessRate</strong> during the time window controlled by the <strong>timeLimit</strong>.
 Additionally if you specify too high <strong>minSuccessRate</strong> you’ll have too many retries, so the upper bound for this is controlled by the
 <strong>maxCount</strong> parameter so that this strategy will calculate the required number of retries according to the <strong>minSuccessRate</strong> but if it’s
 higher than the <strong>maxCount</strong> it will choose <strong>maxCount</strong>.</p>

<ul class="tab" data-tab="59b8becc-8303-4ab2-be55-af3025382346">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="59b8becc-8303-4ab2-be55-af3025382346">
    
        <li class="active">
<pre><code class="language-yaml">flakinessStrategy:
  type: "probability"
  minSuccessRate: 0.7
  maxCount: 3
  timeLimit: "2015-03-14T09:26:53.590Z"
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    flakinessStrategy {
        probabilityBased { 
            minSuccessRate = 0.7
            maxCount = 3
            timeLimit = Instant.now().minus(Duration.parse("PT1H"))
        }
    }
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    flakinessStrategy {
        probabilityBased { 
            minSuccessRate = 0.7
            maxCount = 3
            timeLimit = Instant.now().minus(Duration.parse("PT1H"))
        }
    }
}
</code></pre>
</li>
    
</ul>

<h2 id="retry-strategy">Retry strategy</h2>
<p>This is the logic that kicks in if our preventive logic failed to anticipate such high number of retries. This works after the tests were
 actually executed.</p>

<h3 id="no-retries">No retries</h3>
<p>As the name implies, no retries are done. This is the default mode.</p>

<ul class="tab" data-tab="6bd2214a-3e14-4107-967b-c78e18566b1e">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="6bd2214a-3e14-4107-967b-c78e18566b1e">
    
        <li class="active">
<pre><code class="language-yaml">retryStrategy:
  type: "no-retry"
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    retryStrategy {}
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    retryStrategy {}
}
</code></pre>
</li>
    
</ul>

<h3 id="fixed-quota-retry-strategy">Fixed quota retry strategy</h3>
<p>Parameter <strong>totalAllowedRetryQuota</strong> specifies how many retries at all (for all the tests is total) are allowed. <strong>retryPerTestQuota</strong>
 controls how many retries can be done for each test individually.</p>

<ul class="tab" data-tab="3cec42e7-e4e5-40e9-8b1b-3b04010feb34">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="3cec42e7-e4e5-40e9-8b1b-3b04010feb34">
    
        <li class="active">
<pre><code class="language-yaml">retryStrategy:
  type: "fixed-quota"
  totalAllowedRetryQuota: 100
  retryPerTestQuota: 3
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    retryStrategy {
        fixedQuota { 
            retryPerTestQuota = 3
            totalAllowedRetryQuota = 100
        }
    }
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    retryStrategy {
        fixedQuota { 
            retryPerTestQuota = 3
            totalAllowedRetryQuota = 100
        }
    }
}
</code></pre>
</li>
    
</ul>

<h1 id="additional-parameters">Additional parameters</h1>

<h2 id="test-filtering-configuration">Test filtering configuration</h2>
<p>Filtering of tests is important since usually we as developers have the same codebase for all the different types of tests we want to
 execute. In order to indicate to marathon which tests you want to execute you can use the allowlist and blocklist parameters. First
 allowlist is applied, then the blocklist. Each accepts a <em>TestFilter</em> based on the <em>class name</em>, <em>fully qualified class name</em>, <em>package</em>, 
 <em>annotation</em> or <em>method</em>. Each expects a regular expression as a value.</p>

<p>In order to filter using multiple filters at the same time a <em>composition</em> filter is also available which accepts a list of base filters and
 also an operation such as <strong>UNION</strong>, <strong>INTERSECTION</strong> or <strong>SUBTRACT</strong>. You can create complex filters such as get all the tests
 starting with <em>E2E</em> but get only methods from there ending with <em>Test</em>. Composition filter is not supported by groovy gradle scripts, but 
 is supported if you use gradle kts.</p>

<p>An important thing to mention is that by default platform specific ignore options are not taken into account. This is because a
 cross-platform test runner cannot account for all the possible test frameworks out there. However, each framework’s ignore option can still
 be “explained” to marathon, e.g. JUnit’s <strong>org.junit.Ignore</strong> annotation can be specified in the filtering configuration.</p>

<ul class="tab" data-tab="e23fd631-2fb4-43fa-a2b7-6cf688a63714">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="e23fd631-2fb4-43fa-a2b7-6cf688a63714">
    
        <li class="active">
<pre><code class="language-yaml">filteringConfiguration:
  allowlist:
    - type: "simple-class-name"
      regex: ".*"
    - type: "fully-qualified-class-name"
      regex: ".*"
    - type: "method"
      regex: ".*"
    - type: "composition"
      filters:
        - type: "package"
          regex: ".*"
        - type: "method"
          regex: ".*"
      op: "UNION"
  blocklist:
    - type: "package"
      regex: ".*"
    - type: "annotation"
      regex: ".*"
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    filteringConfiguration {
        allowlist {
            simpleClassNameFilter = [".*"]
            fullyQualifiedClassnameFilter = [".*"]
            testMethodFilter = [".*"]
        }
        blocklist {
            testPackageFilter = [".*"]
            annotationFilter = [".*"]
        }
    }
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    filteringConfiguration { 
        allowlist = listOf(
            SimpleClassnameFilter(".*".toRegex()),
            FullyQualifiedClassnameFilter(".*".toRegex()),
            TestMethodFilter(".*".toRegex()),
            CompositionFilter(
                listOf(
                    TestPackageFilter(".*".toRegex()),
                    TestMethodFilter(".*".toRegex())
                ),
                CompositionFilter.OPERATION.UNION
            )
        )
        blocklist = listOf(
            TestPackageFilter(".*".toRegex()),
            AnnotationFilter(".*".toRegex())
        )
    }
}
</code></pre>
</li>
    
</ul>

<h2 id="test-class-regular-expression">Test class regular expression</h2>
<p>By default, test classes are found using the <code>"^((?!Abstract).)*Test[s]*$"</code> regex. You can override this if you need to.</p>

<ul class="tab" data-tab="caadc992-e403-49e8-8325-1403a3455d8b">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="caadc992-e403-49e8-8325-1403a3455d8b">
    
        <li class="active">
<pre><code class="language-yaml">testClassRegexes:
  - "^((?!Abstract).)*Test[s]*$"
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    testClassRegexes = [
        "^((?!Abstract).)*Test[s]*\$"
    ]
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    testClassRegexes = listOf(
        "^((?!Abstract).)*Test[s]*$"
    )
}
</code></pre>
</li>
    
</ul>

<h2 id="ignore-failures">Ignore failures</h2>
<p>By default, the build fails if some tests failed. If you want to the build to succeed even if some tests failed use <em>true</em>.</p>

<ul class="tab" data-tab="eb46244a-eb0f-4951-bcdc-fd429953815a">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="eb46244a-eb0f-4951-bcdc-fd429953815a">
    
        <li class="active">
<pre><code class="language-yaml">ignoreFailures: true
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    ignoreFailures = true
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    ignoreFailures = true
}
</code></pre>
</li>
    
</ul>

<h2 id="test-output-timeout">Test output timeout</h2>
<p>This parameter specifies the behaviour for the underlying test executor to timeout if there is no output. By default, this is set to 5
minutes.</p>

<ul class="tab" data-tab="74d16f62-8197-42c0-921b-98cd717df46e">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="74d16f62-8197-42c0-921b-98cd717df46e">
    
        <li class="active">
<pre><code class="language-yaml">testOutputTimeoutMillis: 30000
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    testOutputTimeoutMillis = 30000
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    testOutputTimeoutMillis = 30000
}
</code></pre>
</li>
    
</ul>

<h2 id="test-batch-timeout">Test batch timeout</h2>

<p>This parameter specifies the behaviour for the underlying test executor to timeout if the batch execution exceeded some duration. By
default, this is set to 30 minutes.</p>

<ul class="tab" data-tab="a4d417be-91a1-40a0-a5c2-b83af842a7c2">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="a4d417be-91a1-40a0-a5c2-b83af842a7c2">
    
        <li class="active">
<pre><code class="language-yaml">testBatchTimeoutMillis: 900000
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    testBatchTimeoutMillis = 900000
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    testBatchTimeoutMillis = 900000
}
</code></pre>
</li>
    
</ul>

<h2 id="device-provider-init-timeout">Device provider init timeout</h2>
<p>When the test run starts device provider is expected to provide some devices. This should not take more than 3 minutes by default. If your
 setup requires this to be changed please override as following:</p>

<ul class="tab" data-tab="c0d20a9c-fc8a-4efe-8408-53607be71ddc">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="c0d20a9c-fc8a-4efe-8408-53607be71ddc">
    
        <li class="active">
<pre><code class="language-yaml">deviceInitializationTimeoutMillis: 300000
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    deviceInitializationTimeoutMillis = 300000
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    deviceInitializationTimeoutMillis = 300000
}
</code></pre>
</li>
    
</ul>

<h2 id="analytics-tracking">Analytics tracking</h2>
<p>To better understand the use-cases that marathon is used for we’re asking you to provide us with anonymised information about your usage.
 By default, this is disabled. Use <strong>true</strong> to enable.</p>

<ul class="tab" data-tab="ca8c4a4d-2b56-4e7d-a736-66674f20cf57">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="ca8c4a4d-2b56-4e7d-a736-66674f20cf57">
    
        <li class="active">
<pre><code class="language-yaml">analyticsTracking: true
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    analyticsTracking = true
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    analyticsTracking = true
}
</code></pre>
</li>
    
</ul>

<h2 id="uncompleted-test-retry-quota">Uncompleted test retry quota</h2>
<p>By default, tests that don’t have any status reported after execution (for example a device disconnected during the execution) retry
 indefinitely. You can limit the number of total execution for such cases using this option.</p>

<ul class="tab" data-tab="c3f584cb-ed8c-44eb-bb3b-67202be7adff">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="c3f584cb-ed8c-44eb-bb3b-67202be7adff">
    
        <li class="active">
<pre><code class="language-yaml">uncompletedTestRetryQuota: 100
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    uncompletedTestRetryQuota = 100
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    uncompletedTestRetryQuota = 100
}
</code></pre>
</li>
    
</ul>

<h2 id="strict-mode">Strict mode</h2>
<p>By default, if one of the test retries succeeds then the test is considered successfully executed. If you require success status only when
 all retries were executed successfully you can enable the strict mode. This may be useful to verify that flakiness of tests was fixed for
 example.</p>

<ul class="tab" data-tab="efac16b5-eca0-4624-b276-dfc84bcd0a51">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="efac16b5-eca0-4624-b276-dfc84bcd0a51">
    
        <li class="active">
<pre><code class="language-yaml">strictMode: true
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    strictMode = true
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    strictMode = true
}
</code></pre>
</li>
    
</ul>

<h2 id="debug-mode">Debug mode</h2>
<p>Enabled very verbose logging to stdout of all the marathon components. Very useful for debugging.</p>

<ul class="tab" data-tab="733abf9e-df6d-4b12-bce8-151ea272c357">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="733abf9e-df6d-4b12-bce8-151ea272c357">
    
        <li class="active">
<pre><code class="language-yaml">debug: true
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    debug = true
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    debug = true
}
</code></pre>
</li>
    
</ul>

<h2 id="screen-recording-policy">Screen recording policy</h2>
<p>By default, screen recording will only be pulled for tests that failed (<strong>ON_FAILURE</strong> option). This is to save space and also to reduce the
 test duration time since we’re not pulling additional files. If you need to save screen recording regardless of the test pass/failure 
 please use the <strong>ON_ANY</strong> option:</p>

<ul class="tab" data-tab="7c164bbb-5250-4278-b617-50b1a5ddbe62">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="7c164bbb-5250-4278-b617-50b1a5ddbe62">
    
        <li class="active">
<pre><code class="language-yaml">screenRecordingPolicy: "ON_ANY"
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    screenRecordingPolicy = com.malinskiy.marathon.execution.policy.ScreenRecordingPolicy.ON_ANY
}
</code></pre>
</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
    screenRecordingPolicy = com.malinskiy.marathon.execution.policy.ScreenRecordingPolicy.ON_ANY
}
</code></pre>
</li>
    
</ul>

<h1 id="vendor-configuration">Vendor configuration</h1>
<p>See relevant vendor module page, e.g. <a href="/marathon/ven/android.html">Android</a> or <a href="/marathon/ven/ios.html">iOS</a></p>


    </div>
</div>

</div>
<!-- Jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<!-- Highlight -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.1/highlight.min.js"></script>
<script> hljs.initHighlighting(); </script>
<!-- Docsearch -->
<script src="/marathon/js/docsearch.min.js" type="text/javascript"></script>
<!-- Touch gesture support -->
<script src="/marathon/js/hammer.min.js"></script>
<!-- Custom scripts for this template -->
<script src="/marathon/js/functions.js"></script>
<script src="/marathon/js/tabs.js"></script>

</body>
</html>
